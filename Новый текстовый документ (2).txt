import sys
import sqlite3
from PyQt5.QtCore import pyqtSignal
from PyQt5 import QtWidgets
import pandas as pd
from PyQt5.QtCore import QLocale
from PyQt5.QtCore import QDate
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QLineEdit,
    QPushButton, QVBoxLayout, QWidget, QTableWidget,
    QTableWidgetItem, QMessageBox, QInputDialog, QHBoxLayout, QFileDialog, QComboBox
)
from functools import partial

from openpyxl.workbook import Workbook



# Функция для инициализации базы данных
def init_db():
    conn = sqlite3.connect("warehouse_management.db")
    cursor = conn.cursor()

    # Создание таблицы сотрудников
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS employees (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        fullname TEXT NOT NULL,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL
    )
    ''')

    # Создание таблицы администраторов
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS admins (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL
    )
    ''')

    cursor.execute('''
    CREATE TABLE IF NOT EXISTS reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        employee_id INTEGER NOT NULL,
        report_date TEXT NOT NULL,
        content TEXT NOT NULL,
        FOREIGN KEY (employee_id) REFERENCES employees(id)
    )
    ''')
    # Создание таблицы товаров
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS products (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        supplier TEXT NOT NULL,
        category TEXT NOT NULL,
        name TEXT NOT NULL,
        price REAL NOT NULL,
        packaging_quantity INTEGER NOT NULL
    )
    ''')

    conn.commit()
    conn.close()
# Установить учетные данные администратора (один раз)
def setup_admin():
    conn = sqlite3.connect("warehouse_management.db")
    cursor = conn.cursor()

    admin_username = "admin"
    admin_password = "admin123"

    try:
        cursor.execute(
            "INSERT INTO admins (username, password) VALUES (?, ?)",
            (admin_username, admin_password)
        )
        conn.commit()
    except sqlite3.IntegrityError:
        pass  # Администратор уже существует

    conn.close()
# Окно авторизации
class AuthWindow(QMainWindow):
    employee_authenticated = pyqtSignal(int)
    def __init__(self):
        super(AuthWindow, self).__init__()
        self.setWindowTitle("Авторизация - Учет товаров на складе")
        self.resize(400, 300)




        # Создание фонового изображения
        self.set_background_image()

        # Элементы интерфейса
        self.usernameLabel = QLabel("Имя пользователя:")
        self.usernameLabel.setStyleSheet("font-size: 14px; color: #333;")
        self.usernameInput = QLineEdit()
        self.usernameInput.setPlaceholderText("Введите ваше имя пользователя")
        self.usernameInput.setStyleSheet("padding: 10px; border-radius: 5px; border: 1px solid #ccc;")

        self.passwordLabel = QLabel("Пароль:")
        self.passwordLabel.setStyleSheet("font-size: 14px; color: #333;")
        self.passwordInput = QLineEdit()
        self.passwordInput.setEchoMode(QLineEdit.Password)
        self.passwordInput.setPlaceholderText("Введите ваш пароль")
        self.passwordInput.setStyleSheet("padding: 10px; border-radius: 5px; border: 1px solid #ccc;")

        self.loginButton = QPushButton("Войти")
        print("Есть ли loginButton?", hasattr(self, 'loginButton'))  # Проверяет, существует ли атрибут
        print("Тип loginButton:", type(self.loginButton))  # Проверяет тип объекта

        self.loginButton.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.loginButton.clicked.connect(self.login)

        self.registerButton = QPushButton("Зарегистрироваться")
        self.registerButton.setStyleSheet("""
            QPushButton {
                background-color: #008CBA;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #007bb5;
            }
        """)
        self.registerButton.clicked.connect(self.open_register)

        # Макет
        layout = QVBoxLayout()
        layout.addWidget(self.usernameLabel)
        layout.addWidget(self.usernameInput)
        layout.addWidget(self.passwordLabel)
        layout.addWidget(self.passwordInput)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.loginButton)
        button_layout.addWidget(self.registerButton)

        layout.addLayout(button_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

    def set_background_image(self):
        # Фоновое изображение склада (например, картинка склада)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(QPalette.Background, QColor(240, 240, 240))  # Светлый фон
        self.setPalette(p)

    def login(self):
        try:
            username = self.usernameInput.text()
            password = self.passwordInput.text()

            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            # Проверка на сотрудника
            cursor.execute("SELECT * FROM employees WHERE username=? AND password=?", (username, password))
            employee = cursor.fetchone()

            # Проверка на администратора
            cursor.execute("SELECT * FROM admins WHERE username=? AND password=?", (username, password))
            admin = cursor.fetchone()

            if employee:
                self.current_employee_id = employee[0]
                print(f"Employee authenticated with ID: {self.current_employee_id}")
                self.employee_authenticated.emit(self.current_employee_id)  # Испускаем сигнал с ID сотрудника
                self.open_employee_window()
            elif admin:
                self.open_admin_window()
            else:
                QMessageBox.warning(self, "Ошибка", "Неверные имя пользователя или пароль")

            conn.close()
        except Exception as e:
            print(f"Error during login: {e}")
            QMessageBox.warning(self, "Ошибка", f"Произошла ошибка: {e}")

    def get_current_employee_id(self):
        return self.current_employee_id

    def open_register(self):
        self.registerWindow = RegisterWindow()
        self.registerWindow.show()
        self.close()

    def open_employee_window(self):
        # Теперь передаем current_employee_id в окно сотрудника
        self.employeeWindow = EmployeeWindow(employee_id=self.current_employee_id)
        self.employeeWindow.show()
        self.close()

    def open_admin_window(self):
        self.adminWindow = AdminWindow()
        self.adminWindow.show()
        self.close()

# Окно регистрации
class RegisterWindow(QMainWindow):
    def __init__(self):
        super(RegisterWindow, self).__init__()
        self.setWindowTitle("Регистрация - Учет товаров на складе")
        self.resize(400, 300)

        self.set_background_image()

        # Элементы интерфейса
        self.fullnameLabel = QLabel("ФИО:")
        self.fullnameLabel.setStyleSheet("font-size: 14px; color: #333;")
        self.fullnameInput = QLineEdit()
        self.fullnameInput.setPlaceholderText("Введите ваше ФИО")
        self.fullnameInput.setStyleSheet("padding: 10px; border-radius: 5px; border: 1px solid #ccc;")

        self.usernameLabel = QLabel("Имя пользователя:")
        self.usernameLabel.setStyleSheet("font-size: 14px; color: #333;")
        self.usernameInput = QLineEdit()
        self.usernameInput.setPlaceholderText("Введите имя пользователя")
        self.usernameInput.setStyleSheet("padding: 10px; border-radius: 5px; border: 1px solid #ccc;")

        self.passwordLabel = QLabel("Пароль:")
        self.passwordLabel.setStyleSheet("font-size: 14px; color: #333;")
        self.passwordInput = QLineEdit()
        self.passwordInput.setEchoMode(QLineEdit.Password)
        self.passwordInput.setPlaceholderText("Введите пароль")
        self.passwordInput.setStyleSheet("padding: 10px; border-radius: 5px; border: 1px solid #ccc;")

        self.registerButton = QPushButton("Зарегистрироваться")
        self.registerButton.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.registerButton.clicked.connect(self.register)

        self.backButton = QPushButton("Назад")
        self.backButton.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #e53935;
            }
        """)
        self.backButton.clicked.connect(self.open_auth_window)

        # Макет
        layout = QVBoxLayout()
        layout.addWidget(self.fullnameLabel)
        layout.addWidget(self.fullnameInput)
        layout.addWidget(self.usernameLabel)
        layout.addWidget(self.usernameInput)
        layout.addWidget(self.passwordLabel)
        layout.addWidget(self.passwordInput)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.registerButton)
        button_layout.addWidget(self.backButton)

        layout.addLayout(button_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

    def set_background_image(self):
        # Фоновое изображение (или просто светлый фон)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(QPalette.Background, QColor(240, 240, 240))  # Светлый фон
        self.setPalette(p)

    def register(self):
        fullname = self.fullnameInput.text().strip()
        username = self.usernameInput.text().strip()
        password = self.passwordInput.text().strip()

        if not fullname or not username or not password:
            QMessageBox.warning(self, "Ошибка", "Заполните все поля.")
            return

        conn = sqlite3.connect("warehouse_management.db")
        cursor = conn.cursor()

        try:
            cursor.execute(
                "INSERT INTO employees (fullname, username, password) VALUES (?, ?, ?)",
                (fullname, username, password)
            )
            conn.commit()
            QMessageBox.information(self, "Успех", "Регистрация прошла успешно")
            self.open_auth_window()
        except sqlite3.IntegrityError:
            QMessageBox.warning(self, "Ошибка", "Пользователь с таким именем уже существует")

        conn.close()

    def open_auth_window(self):
        self.authWindow = AuthWindow()
        self.authWindow.show()
        self.close()

# Окно сотрудника
from PyQt5.QtCore import Qt

class EmployeeWindow(QMainWindow):
    def __init__(self, employee_id=None):
        super(EmployeeWindow, self).__init__()
        self.setWindowTitle("Окно сотрудника - Учет товаров на складе")
        self.resize(800, 600)

        self.set_background_image()

        # Инициализация ID сотрудника
        self.current_employee_id = employee_id

        self.productsTable = QTableWidget()
        self.productsTable.setColumnCount(6)
        self.productsTable.setHorizontalHeaderLabels(
            ["Поставщик", "Категория", "Наименование", "Цена", "Кол-во упаковок", "Стоимость"]
        )
        self.productsTable.setSortingEnabled(True)
        self.productsTable.setStyleSheet("""
            QTableWidget {
                border: 1px solid #ccc;
                background-color: #fff;
            }
            QHeaderView::section {
                background-color: #f2f2f2;
                font-weight: bold;
                padding: 10px;
            }
            QTableWidget::item {
                padding: 10px;
            }
        """)

        # Поле поиска и фильтрации
        self.searchInput = QLineEdit()
        self.searchInput.setPlaceholderText("Поиск...")
        self.searchInput.textChanged.connect(self.filter_products)

        self.supplierFilter = QComboBox()
        self.supplierFilter.addItem("Все поставщики")
        self.supplierFilter.currentTextChanged.connect(self.filter_products)

        self.categoryFilter = QComboBox()
        self.categoryFilter.addItem("Все категории")
        self.categoryFilter.currentTextChanged.connect(self.filter_products)

        self.nameFilter = QComboBox()
        self.nameFilter.addItem("Все наименования")
        self.nameFilter.currentTextChanged.connect(self.filter_products)

        # Кнопки управления
        self.addProductButton = QPushButton("Добавить товар")
        self.addProductButton.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.addProductButton.clicked.connect(self.add_product)

        self.createReportButton = QPushButton("Создать отчет и экспортировать")
        self.createReportButton.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        self.createReportButton.clicked.connect(self.create_report_and_export_with_products)

        self.deleteProductButton = QPushButton("Удалить товар")
        self.deleteProductButton.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #e53935;
            }
        """)
        self.deleteProductButton.clicked.connect(self.delete_product)

        self.backButton = QPushButton("Назад")
        self.backButton.setStyleSheet("""
            QPushButton {
                background-color: #f1f1f1;
                color: #333;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
                border: 1px solid #ccc;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        self.backButton.clicked.connect(self.open_auth_window)

        # Макет фильтров
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Поставщик:"))
        filter_layout.addWidget(self.supplierFilter)
        filter_layout.addWidget(QLabel("Категория:"))
        filter_layout.addWidget(self.categoryFilter)
        filter_layout.addWidget(QLabel("Наименование:"))
        filter_layout.addWidget(self.nameFilter)
        filter_layout.addWidget(QLabel("Поиск:"))
        filter_layout.addWidget(self.searchInput)

        # Основной макет
        layout = QVBoxLayout()
        layout.addLayout(filter_layout)
        layout.addWidget(QLabel("Товары на складе:"))
        layout.addWidget(self.productsTable)
        layout.addWidget(self.addProductButton)
        layout.addWidget(self.deleteProductButton)
        layout.addWidget(self.createReportButton)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.backButton)
        layout.addLayout(button_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        self.load_filters()
        self.load_products()

    def set_background_image(self):
        # Фоновое изображение (или просто светлый фон)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(QPalette.Background, QColor(240, 240, 240))  # Светлый фон
        self.setPalette(p)

    def load_filters(self):
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            # Загрузка поставщиков
            cursor.execute("SELECT DISTINCT supplier FROM products")
            suppliers = cursor.fetchall()
            self.supplierFilter.addItems([supplier[0] for supplier in suppliers])

            # Загрузка категорий
            cursor.execute("SELECT DISTINCT category FROM products")
            categories = cursor.fetchall()
            self.categoryFilter.addItems([category[0] for category in categories])

            # Загрузка наименований
            cursor.execute("SELECT DISTINCT name FROM products")
            names = cursor.fetchall()
            self.nameFilter.addItems([name[0] for name in names])

        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка базы данных", f"Ошибка при загрузке фильтров: {e}")
        finally:
            conn.close()

    def filter_products(self):
        supplier = self.supplierFilter.currentText()
        category = self.categoryFilter.currentText()
        name = self.nameFilter.currentText()
        search_text = self.searchInput.text().lower()

        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            query = """
                SELECT supplier, category, name, price, packaging_quantity, price * packaging_quantity AS total_cost 
                FROM products
                WHERE 1=1
            """
            params = []

            if supplier != "Все поставщики":
                query += " AND supplier = ?"
                params.append(supplier)

            if category != "Все категории":
                query += " AND category = ?"
                params.append(category)

            if name != "Все наименования":
                query += " AND name = ?"
                params.append(name)

            if search_text:
                query += " AND (supplier LIKE ? OR category LIKE ? OR name LIKE ?)"
                params.extend([f"%{search_text}%"] * 3)

            cursor.execute(query, params)
            products = cursor.fetchall()

            self.productsTable.setRowCount(len(products))
            for row_num, row_data in enumerate(products):
                for col_num, col_data in enumerate(row_data):
                    item = QTableWidgetItem(str(col_data))
                    self.productsTable.setItem(row_num, col_num, item)

        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка базы данных", f"Ошибка при фильтрации товаров: {e}")
        finally:
            conn.close()

    # Остальные методы остаются без изменений

    def set_background_image(self):
        # Фоновое изображение (или просто светлый фон)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(QPalette.Background, QColor(240, 240, 240))  # Светлый фон
        self.setPalette(p)

    def open_auth_window(self):
        try:
            self.authWindow = AuthWindow()  # Создаем окно авторизации
            self.authWindow.employee_authenticated.connect(self.set_employee_id)  # Подключаем сигнал
            self.authWindow.show()
            self.close()  # Закрываем текущее окно
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при открытии окна авторизации: {e}")

    def set_employee_id(self, employee_id):
        # Устанавливаем ID сотрудника после успешной авторизации
        self.current_employee_id = employee_id

    def get_employee_id(self):
        # Возвращаем ID текущего сотрудника
        if self.current_employee_id is None:
            QMessageBox.warning(self, "Ошибка", "Необходимо авторизоваться")
            return None
        return self.current_employee_id

    def create_report_and_export_with_products(self):
        try:

            report_content, ok = QInputDialog.getText(self, 'Создание отчета', 'Введите содержание отчета:')
            if not ok or not report_content:
                return


            employee_id = self.get_employee_id()

            if employee_id is None:
                QMessageBox.warning(self, "Ошибка", "Необходимо авторизоваться")
                return

            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute(
                "INSERT INTO reports (employee_id, report_date, content) VALUES (?, ?, ?)",
                (employee_id, QDate.currentDate().toString(), report_content)
            )
            conn.commit()

            self.export_report_to_excel_with_products(report_content)

            QMessageBox.information(self, "Успех", "Отчет успешно создан и экспортирован.")
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка базы данных", f"Ошибка при работе с базой данных: {e}")
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Произошла ошибка: {e}")
        finally:
            conn.close()

    def export_report_to_excel_with_products(self, report_content):
        try:
            # Создание нового Excel файла
            wb = Workbook()
            ws = wb.active
            ws.title = "Отчет о товарах"

            # Добавление заголовка отчета
            ws.append(["Содержание отчета"])
            ws.append([report_content])
            ws.append([""])  # Пустая строка для разделения

            # Добавление заголовков таблицы с товарами
            headers = ["Поставщик", "Категория", "Наименование", "Цена", "Кол-во упаковок", "Стоимость"]
            ws.append(headers)

            # Получаем данные о товарах
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute("""
                SELECT supplier, category, name, price, packaging_quantity, price * packaging_quantity AS total_cost
                FROM products
            """)
            products = cursor.fetchall()

            # Заполнение Excel данными о товарах
            for product in products:
                ws.append(list(product))

            # Окно выбора пути для сохранения
            file_path, _ = QFileDialog.getSaveFileName(self, "Сохранить отчет", "", "Excel Files (*.xlsx);;All Files (*)")
            if file_path:
                wb.save(file_path)
                QMessageBox.information(self, "Успех", f"Отчет успешно экспортирован в {file_path}")
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Произошла ошибка при экспорте отчета: {e}")

    def load_products(self):
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute("""
                SELECT supplier, category, name, price, packaging_quantity, price * packaging_quantity AS total_cost 
                FROM products
            """)
            products = cursor.fetchall()

            if products:
                self.productsTable.setRowCount(len(products))
                for row_num, row_data in enumerate(products):
                    for col_num, col_data in enumerate(row_data):
                        item = QTableWidgetItem(str(col_data))
                        self.productsTable.setItem(row_num, col_num, item)
            else:
                QMessageBox.warning(self, "Ошибка", "Нет данных для загрузки товаров.")
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при загрузке товаров: {e}")
        finally:
            conn.close()

    def add_product(self):
        try:
            supplier, ok1 = QInputDialog.getText(self, 'Добавление товара', 'Поставщик:')
            if not ok1 or not supplier:
                return

            category, ok2 = QInputDialog.getText(self, 'Добавление товара', 'Категория:')
            if not ok2 or not category:
                return

            name, ok3 = QInputDialog.getText(self, 'Добавление товара', 'Наименование:')
            if not ok3 or not name:
                return

            price, ok4 = QInputDialog.getDouble(self, 'Добавление товара', 'Цена:', decimals=2)
            if not ok4:
                return

            packaging_quantity, ok5 = QInputDialog.getInt(self, 'Добавление товара', 'Кол-во упаковок:', min=0)
            if not ok5:
                return

            # Добавление товара в базу
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute(
                "INSERT INTO products (supplier, category, name, price, packaging_quantity) VALUES (?, ?, ?, ?, ?)",
                (supplier, category, name, price, packaging_quantity)
            )
            conn.commit()
            QMessageBox.information(self, "Успех", "Товар успешно добавлен")
            self.load_products()  # Обновление списка товаров после добавления

        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка базы данных", f"Произошла ошибка при добавлении товара: {e}")
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Произошла ошибка: {e}")
        finally:
            conn.close()

    def delete_product(self):
        selected_items = self.productsTable.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Ошибка", "Пожалуйста, выберите товар для удаления.")
            return

        row = selected_items[0].row()

        # Получить данные товара
        supplier = self.productsTable.item(row, 0).text()
        category = self.productsTable.item(row, 1).text()
        name = self.productsTable.item(row, 2).text()

        # Удалить товар из базы
        conn = sqlite3.connect("warehouse_management.db")
        cursor = conn.cursor()

        try:
            cursor.execute(
                "DELETE FROM products WHERE supplier=? AND category=? AND name=?",
                (supplier, category, name)
            )
            conn.commit()
            QMessageBox.information(self, "Успех", "Товар успешно удален")
            self.load_products()  # Обновить таблицу после удаления
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка базы данных", f"Ошибка при удалении товара: {e}")
        finally:
            conn.close()

    def open_auth_window(self):
        try:
            print("Opening AuthWindow...")
            self.authWindow = AuthWindow()  # Создаем окно авторизации
            print("AuthWindow created successfully.")

            # Подключаем сигнал
            self.authWindow.employee_authenticated.connect(self.set_employee_id)
            print("Signal connected successfully.")

            self.authWindow.show()
            self.close()  # Закрываем текущее окно
        except Exception as e:
            print(f"Error when opening AuthWindow: {e}")
            QMessageBox.warning(self, "Ошибка", f"Ошибка при открытии окна авторизации: {e}")

class NumericTableWidgetItem(QTableWidgetItem):
    def __lt__(self, other):
        # Проверяем, что сравниваем с другим элементом
        if isinstance(other, QTableWidgetItem):
            try:
                # Преобразуем значения в числа и сравниваем
                return float(self.text()) < float(other.text())
            except ValueError:
                # Если не удается преобразовать, сортируем как строки
                return self.text() < other.text()
        return super().__lt__(other)


# Окно администратора
class AdminWindow(QMainWindow):
    def __init__(self):
        super(AdminWindow, self).__init__()
        self.setWindowTitle("Окно администратора - Учет товаров на складе")
        self.resize(800, 600)

        self.set_background_image()

        self.productsTable = QTableWidget()
        self.productsTable.setColumnCount(6)
        self.productsTable.setHorizontalHeaderLabels(
            ["Поставщик", "Категория", "Наименование", "Цена", "Кол-во упаковок", "Стоимость"]
        )
        self.productsTable.setSortingEnabled(True)
        self.productsTable.setStyleSheet("""
            QTableWidget {
                border: 1px solid #ccc;
                background-color: #fff;
            }
            QHeaderView::section {
                background-color: #f2f2f2;
                font-weight: bold;
                padding: 10px;
            }
            QTableWidget::item {
                padding: 10px;
            }
        """)

        # Фильтры
        self.supplierFilter = QComboBox()
        self.supplierFilter.addItem("Все поставщики")
        self.supplierFilter.currentTextChanged.connect(self.apply_filters)

        self.categoryFilter = QComboBox()
        self.categoryFilter.addItem("Все категории")
        self.categoryFilter.currentTextChanged.connect(self.apply_filters)

        self.nameFilter = QComboBox()
        self.nameFilter.addItem("Все наименования")
        self.nameFilter.currentTextChanged.connect(self.apply_filters)

        self.searchBox = QLineEdit()
        self.searchBox.setPlaceholderText("Поиск по наименованию...")
        self.searchBox.textChanged.connect(self.apply_filters)

        # Кнопки управления
        self.addProductButton = QPushButton("Добавить товар")
        self.addProductButton.setStyleSheet("""
                    QPushButton {
                        background-color: #4CAF50;
                        color: white;
                        padding: 12px 20px;
                        border-radius: 5px;
                        font-size: 16px;
                    }
                    QPushButton:hover {
                        background-color: #45a049;
                    }
                """)
        self.addProductButton.clicked.connect(self.add_product)

        self.editProductButton = QPushButton("Редактировать товар")
        self.editProductButton.setStyleSheet("""
                    QPushButton {
                        background-color: #FFC107;
                        color: white;
                        padding: 12px 20px;
                        border-radius: 5px;
                        font-size: 16px;
                    }
                    QPushButton:hover {
                        background-color: #FF9800;
                    }
                """)
        self.editProductButton.clicked.connect(self.edit_product)

        self.viewEmployeesButton = QPushButton("Управление сотрудниками")
        self.viewEmployeesButton.setStyleSheet("""
                    QPushButton {
                        background-color: #2196F3;
                        color: white;
                        padding: 12px 20px;
                        border-radius: 5px;
                        font-size: 16px;
                    }
                    QPushButton:hover {
                        background-color: #1976D2;
                    }
                """)
        self.viewEmployeesButton.clicked.connect(self.open_employees_window)

        self.backButton = QPushButton("Назад")
        self.backButton.setStyleSheet("""
                    QPushButton {
                        background-color: #f1f1f1;
                        color: #333;
                        padding: 12px 20px;
                        border-radius: 5px;
                        font-size: 16px;
                        border: 1px solid #ccc;
                    }
                    QPushButton:hover {
                        background-color: #e0e0e0;
                    }
                """)
        self.backButton.clicked.connect(self.open_auth_window)

        # Макет фильтров
        filterLayout = QHBoxLayout()
        filterLayout.addWidget(QLabel("Поставщик:"))
        filterLayout.addWidget(self.supplierFilter)
        filterLayout.addWidget(QLabel("Категория:"))
        filterLayout.addWidget(self.categoryFilter)
        filterLayout.addWidget(QLabel("Наименование:"))
        filterLayout.addWidget(self.nameFilter)
        filterLayout.addWidget(QLabel("Поиск:"))
        filterLayout.addWidget(self.searchBox)

        # Основной макет
        layout = QVBoxLayout()
        layout.addLayout(filterLayout)
        layout.addWidget(self.productsTable)
        layout.addWidget(self.addProductButton)
        layout.addWidget(self.editProductButton)
        layout.addWidget(self.viewEmployeesButton)
        layout.addWidget(self.backButton)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        self.load_products()
        self.populate_filters()

    def set_background_image(self):
        self.setAutoFillBackground(True)
        palette = self.palette()
        palette.setColor(QPalette.Background, QColor(240, 240, 240))
        self.setPalette(palette)

    def load_products(self):
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute("""
                SELECT supplier, category, name, price, packaging_quantity, price * packaging_quantity AS total_cost
                FROM products
            """)
            self.products = cursor.fetchall()

            self.display_products(self.products)
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при загрузке товаров: {e}")
        finally:
            conn.close()

    def display_products(self, products):
        self.productsTable.setRowCount(len(products))
        for row_num, row_data in enumerate(products):
            for col_num, col_data in enumerate(row_data):
                self.productsTable.setItem(row_num, col_num, QTableWidgetItem(str(col_data)))

    def populate_filters(self):
        suppliers = set()
        categories = set()
        names = set()

        for product in self.products:
            suppliers.add(product[0])
            categories.add(product[1])
            names.add(product[2])

        self.supplierFilter.addItems(sorted(suppliers))
        self.categoryFilter.addItems(sorted(categories))
        self.nameFilter.addItems(sorted(names))

    def apply_filters(self):
        supplier = self.supplierFilter.currentText()
        category = self.categoryFilter.currentText()
        name = self.nameFilter.currentText()
        search_text = self.searchBox.text().strip().lower()

        filtered_products = [
            product for product in self.products
            if (supplier == "Все поставщики" or product[0] == supplier)
            and (category == "Все категории" or product[1] == category)
            and (name == "Все наименования" or product[2] == name)
            and (search_text in product[2].lower())
        ]

        self.display_products(filtered_products)

    def open_employees_window(self):
        self.employeesWindow = ManageEmployeesWindow()
        self.employeesWindow.show()

    def add_product(self):
        try:
            # Устанавливаем русский язык для кнопок диалогов
            QLocale.setDefault(QLocale(QLocale.Russian, QLocale.Russia))

            # Получаем данные от пользователя
            supplier, ok1 = QInputDialog.getText(self, 'Добавление товара', 'Поставщик:')
            if not ok1 or not supplier.strip():  # Проверяем нажатие "Отмена" или пустое значение
                QMessageBox.warning(self, "Ошибка", "Поле 'Поставщик' не может быть пустым.")
                return

            category, ok2 = QInputDialog.getText(self, 'Добавление товара', 'Категория:')
            if not ok2 or not category.strip():  # Проверяем нажатие "Отмена" или пустое значение
                QMessageBox.warning(self, "Ошибка", "Поле 'Категория' не может быть пустым.")
                return

            name, ok3 = QInputDialog.getText(self, 'Добавление товара', 'Наименование:')
            if not ok3 or not name.strip():  # Проверяем нажатие "Отмена" или пустое значение
                QMessageBox.warning(self, "Ошибка", "Поле 'Наименование' не может быть пустым.")
                return

            # Получаем цену
            price, ok4 = QInputDialog.getDouble(self, 'Добавление товара', 'Цена:', decimals=2)
            if not ok4 or price <= 0:  # Проверяем нажатие "Отмена" или некорректное значение
                QMessageBox.warning(self, "Ошибка", "Цена должна быть числом больше 0.")
                return

            # Получаем количество упаковок
            packaging_quantity, ok5 = QInputDialog.getInt(self, 'Добавление товара', 'Кол-во упаковок:', min=0)
            if not ok5:  # Проверяем нажатие "Отмена"
                return

            # Добавляем данные в базу
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute(
                "INSERT INTO products (supplier, category, name, price, packaging_quantity) VALUES (?, ?, ?, ?, ?)",
                (supplier.strip(), category.strip(), name.strip(), price, packaging_quantity)
            )
            conn.commit()

            QMessageBox.information(self, "Успех", "Товар успешно добавлен!")
            self.load_products()  # Перезагружаем список товаров

        except sqlite3.Error as e:
            QMessageBox.critical(self, "Ошибка базы данных", f"Ошибка при добавлении товара: {e}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Непредвиденная ошибка: {e}")
        finally:
            if 'conn' in locals() and conn:  # Закрываем соединение, если оно было открыто
                conn.close()

    def load_employees(self):
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute("SELECT id, username FROM employees")
            employees = cursor.fetchall()

            self.employeesTable.setRowCount(len(employees))
            for row_num, row_data in enumerate(employees):
                self.employeesTable.setItem(row_num, 0, QTableWidgetItem(str(row_data[0])))  # ID
                self.employeesTable.setItem(row_num, 1, QTableWidgetItem(str(row_data[1])))  # Имя пользователя

                delete_button = QPushButton("Удалить")
                delete_button.clicked.connect(partial(self.delete_employee, row_data[0]))
                self.employeesTable.setCellWidget(row_num, 2, delete_button)
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при загрузке сотрудников: {e}")
        finally:
            conn.close()

    def delete_employee(self, employee_id):
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            cursor.execute("DELETE FROM employees WHERE id=?", (employee_id,))
            conn.commit()

            QMessageBox.information(self, "Успех", "Сотрудник успешно удален")
            self.load_employees()
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при удалении сотрудника: {e}")
        finally:
            conn.close()

    def edit_product(self):
        selected_items = self.productsTable.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Ошибка", "Пожалуйста, выберите товар для редактирования.")
            return

        row = selected_items[0].row()

        # Получить текущие значения
        supplier = self.productsTable.item(row, 0).text()
        category = self.productsTable.item(row, 1).text()
        name = self.productsTable.item(row, 2).text()
        price = float(self.productsTable.item(row, 3).text())
        packaging_quantity = int(self.productsTable.item(row, 4).text())

        # Окна ввода новых данных
        new_supplier, ok1 = QInputDialog.getText(self, "Редактирование товара", "Поставщик:", text=supplier)
        if not ok1 or not new_supplier:
            return

        new_category, ok2 = QInputDialog.getText(self, "Редактирование товара", "Категория:", text=category)
        if not ok2 or not new_category:
            return

        new_name, ok3 = QInputDialog.getText(self, "Редактирование товара", "Наименование:", text=name)
        if not ok3 or not new_name:
            return

        new_price, ok4 = QInputDialog.getDouble(self, "Редактирование товара", "Цена:", decimals=2, value=price)
        if not ok4:
            return

        new_packaging_quantity, ok5 = QInputDialog.getInt(self, "Редактирование товара", "Кол-во упаковок:",
                                                          min=0, value=packaging_quantity)
        if not ok5:
            return

        # Обновить данные в базе
        conn = sqlite3.connect("warehouse_management.db")
        cursor = conn.cursor()

        try:
            cursor.execute(
                "UPDATE products SET supplier=?, category=?, name=?, price=?, packaging_quantity=? WHERE supplier=? AND category=? AND name=?",
                (new_supplier, new_category, new_name, new_price, new_packaging_quantity, supplier, category, name)
            )
            conn.commit()
            QMessageBox.information(self, "Успех", "Товар успешно обновлен.")
            self.load_products()  # Обновить таблицу товаров
        except sqlite3.Error as e:
            QMessageBox.warning(self, "Ошибка", f"Произошла ошибка при редактировании товара: {e}")
        finally:
            conn.close()

    def open_auth_window(self):
        try:
            self.authWindow = AuthWindow()  # Создаем окно авторизации
            self.authWindow.show()
            self.close()  # Закрываем текущее окно администратора
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Ошибка при открытии окна авторизации: {e}")

    def open_employees_window(self):
        """Закрывает окно администратора и открывает окно управления сотрудниками"""
        self.close()  # Закрыть окно администратора
        self.employeesWindow = ManageEmployeesWindow()  # Открыть окно управления сотрудниками
        self.employeesWindow.show()

# Окно управления сотрудниками
class ManageEmployeesWindow(QMainWindow):
    def __init__(self):
        super(ManageEmployeesWindow, self).__init__()
        self.setWindowTitle("Управление сотрудниками - Учет товаров на складе")
        self.resize(800, 600)

        self.set_background_image()

        # Создание таблицы сотрудников
        self.employeesTable = QTableWidget()
        self.employeesTable.setColumnCount(3)
        self.employeesTable.setHorizontalHeaderLabels(["ID", "ФИО", "Имя пользователя"])
        self.employeesTable.setStyleSheet("""
            QTableWidget {
                border: 1px solid #ccc;
                background-color: #fff;
            }
            QHeaderView::section {
                background-color: #f2f2f2;
                font-weight: bold;
                padding: 10px;
            }
            QTableWidget::item {
                padding: 10px;
            }
        """)

        # Кнопка для удаления сотрудника
        self.deleteEmployeeButton = QPushButton("Удалить сотрудника")
        self.deleteEmployeeButton.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #e53935;
            }
        """)
        self.deleteEmployeeButton.clicked.connect(self.delete_employee)

        # Кнопка "Назад"
        self.backButton = QPushButton("Назад")
        self.backButton.setStyleSheet("""
            QPushButton {
                background-color: #f1f1f1;
                color: #333;
                padding: 12px 20px;
                border-radius: 5px;
                font-size: 16px;
                border: 1px solid #ccc;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        self.backButton.clicked.connect(self.open_admin_window)

        # Макет
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Сотрудники:"))
        layout.addWidget(self.employeesTable)
        layout.addWidget(self.deleteEmployeeButton)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.backButton)
        layout.addLayout(button_layout)

        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        self.load_employees()

    def set_background_image(self):
        # Фоновое изображение (или просто светлый фон)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(QPalette.Background, QColor(240, 240, 240))  # Светлый фон
        self.setPalette(p)

    def load_employees(self):
        """Загружает список сотрудников из базы данных в таблицу"""
        try:
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()

            # Запрос с правильными именами столбцов
            cursor.execute("SELECT id, fullname, username FROM employees")
            employees = cursor.fetchall()

            self.employeesTable.setRowCount(len(employees))

            for row_num, row_data in enumerate(employees):
                for col_num, col_data in enumerate(row_data):
                    self.employeesTable.setItem(row_num, col_num, QTableWidgetItem(str(col_data)))

            # Скрываем столбец ID для пользователя
            self.employeesTable.setColumnHidden(0, True)

            conn.close()
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка загрузки данных сотрудников: {str(e)}")

    def delete_employee(self):
        """Удаляет выбранного сотрудника из базы данных"""
        selected_row = self.employeesTable.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Ошибка", "Выберите сотрудника для удаления.")
            return

        try:
            # Проверяем наличие ID в выбранной строке
            employee_id_item = self.employeesTable.item(selected_row, 0)
            if employee_id_item is None:
                QMessageBox.critical(self, "Ошибка", "Не удалось определить ID сотрудника.")
                return

            employee_id = employee_id_item.text()

            # Подтверждение удаления
            reply = QMessageBox.question(
                self, "Подтверждение удаления",
                f"Вы уверены, что хотите удалить сотрудника с ID {employee_id}?",
                QMessageBox.Yes | QMessageBox.No
            )
            if reply != QMessageBox.Yes:
                return

            # Удаляем сотрудника из базы
            conn = sqlite3.connect("warehouse_management.db")
            cursor = conn.cursor()
            cursor.execute("DELETE FROM employees WHERE id=?", (employee_id,))
            conn.commit()
            conn.close()

            QMessageBox.information(self, "Удаление", "Сотрудник удален успешно.")

            # Обновляем таблицу
            self.load_employees()
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при удалении сотрудника: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Непредвиденная ошибка: {str(e)}")

    def open_admin_window(self):
        """Закрывает текущее окно и открывает окно администратора"""
        self.close()  # Закрыть окно управления сотрудниками
        if not hasattr(self, 'adminWindow') or not self.adminWindow.isVisible():
            self.adminWindow = AdminWindow()  # Создать окно администратора, если оно еще не создано
            self.adminWindow.show()
        else:
            # Если окно администратора уже открыто, просто активировать его
            self.adminWindow.raise_()
            self.adminWindow.activateWindow()
# Запуск приложения
if __name__ == "__main__":
    app = QApplication(sys.argv)
    init_db()
    setup_admin()  # Установить администратора один раз
    mainWindow = AuthWindow()
    mainWindow.show()
    sys.exit(app.exec_())